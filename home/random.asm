Random::
; A simple hardware-based random number generator (RNG).

; Two random numbers are generated by adding and subtracting
; the divider to the respective values every time it's called.

; The divider is a register that increments at a rate of 16384Hz.
; For comparison, the Game Boy operates at a clock speed of 4.2MHz.

; Additionally, an equivalent function is executed in VBlank.

; This leaves a with the value in hRandomSub.

	push bc

	ldh a, [rDIV]
	ld b, a
	ldh a, [hRandomAdd]
	adc b
	ldh [hRandomAdd], a

	ldh a, [rDIV]
	ld b, a
	ldh a, [hRandomSub]
	sbc b
	ldh [hRandomSub], a

	pop bc
	ret

BattleRandom::
; _BattleRandom lives in another bank.

; It handles all RNG calls in the battle engine, allowing
; link battles to remain in sync using a shared PRNG.

	ldh a, [hROMBank]
	push af
	ld a, BANK(_BattleRandom)
	rst Bankswitch

	call _BattleRandom

	ldh [hPredefHL + 1], a
	pop af
	rst Bankswitch
	ldh a, [hPredefHL + 1]
	ret

RandomRange::
; Return a random number between 0 and a (non-inclusive).

	push bc
	ld c, a

	; b = $100 % c
	xor a
	sub c
.mod
	sub c
	jr nc, .mod
	add c
	ld b, a

	; Get a random number
	; from 0 to $ff - b.
	push bc
.loop
	call Random
	ldh a, [hRandomAdd]
	ld c, a
	add b
	jr c, .loop
	ld a, c
	pop bc

	call SimpleDivide

	pop bc
	ret

LinearFeedbackShiftRegister::
; implementation of an 8bit Gallois Linear Feedback Shift Register
; generates a random number based on the value of a. Ideally taken from rDIV
; used for the personality value and when more randomness is desired (IVs?)
; may be totally useless but it's cool
; http://datagenetics.com/blog/november12017/index.html

    ;ldh a, [rDIV]
    srl a ;shift a
    ret z ;if the carry is 0, don't do anything else

	;continue if carry is 1
    push bc
    push hl

    ld b, a
    ld a, [hRandomSub] ; we pick the mask based on the value of hRandomSub. Could have been hRandomAdd as well
    and %00001111
    ld hl, LFSRMasks
    ; Point to entry in the table by doing hl + a
    add l
    ld l, a
    adc h
    sub l
    ld h, a
    ; Get value from table 
    ld a, [hl]
    xor b ; we xor the value of a, the mask, with b, the random number initially in a
    pop hl
    pop bc
    ret

LFSRMasks:
MACRO lfsr_mask
    db \1
ENDM
    lfsr_mask %10001110
    lfsr_mask %10010101
    lfsr_mask %10010110
    lfsr_mask %10100110
    lfsr_mask %10101111
    lfsr_mask %10110001
    lfsr_mask %10110010
    lfsr_mask %10110100
    lfsr_mask %10111000
    lfsr_mask %11000011
    lfsr_mask %11000110
    lfsr_mask %11010100
    lfsr_mask %11100001
    lfsr_mask %11100111
    lfsr_mask %11110011
    lfsr_mask %11111010
